\chapter{Le travail réalisé}

%
%
%
\section{État de l'existant}
Quand je suis arrivé au laboratoire \textit{CIRDLES}, le coeur du logiciel avait déja été réalisé par John Zeringue, mon partenaire principal pendant ce stage. Il y avait déjà un tableau où l'on pouvait entrer des données, et on pouvait déja génèrer un graphique avec les ellipses d'erreurs et une des lignes Concordia\footnote{On savait pas d'ailleurs à l'époque qu'il y avait plusieurs lignes Concordia. On appelait tout simplement celle qui était dans le logiciel ``La ligne concordia''. C'est bien plus tard dans le projet que l'on a découvert qu'il y en avait plusieurs.}.

Le moment où je suis arrivé coincide avec le moment où le Docteur Bowring nous a donné le cas d'utilisation primaire du chercheur Australien à implémenter. Le cas d'utilisation peut se résumer aux étapes suivantes :
\begin{enumerate}
\item Le geochronologiste a des données dans une feuille Excel qui représente des ratios et leur inexactitude. Il les copie.
\item Il entre dans notre logiciel et colle les donnée dans un tableau similaire.
\item Il demande à génèrer le schema, le logiciel le lui montre.
\item Il a ensuite la possibilité de l'exporter au format SVG
\end{enumerate}

Après avoir passé deux jours à me renseigner sur la géochronologie en lisant une publication du Docteur Bowring ou encore en regardant un DVD sur le sujet, %Cette phrase mérite peut-être sa propre section. Ou elle l'aura dans la quatrieme partie.
j'ai commencé avec John à implémenter ce cas d'utilisation.

%
%
%
\section{L'implementation du cas d'utilisation}
Il n'y a avait pas beaucoup de travail pour adapter le logiciel au cas d'utilisation. Pendant que John s'est occupé de l'import de données depuis \textit{Excel}, j'ai créé le \textit{ColumnSelectorView}.

%
%
\subsection{Le \textit{ColumnSelectorView}}
Dans la version d'alors du logiciel, le tableau n'avait que cinq colonnes, une pour chaque variables dont nous avions besoin pour tracer les ellipses d'erreurs. Nous avons décidé de permettre aux utilisateurs d'insérer autant de colonnes qu'ils souhaitaient depuis leur feuille de calcul Excel. Cela demandait cependant une étape supplémentaire : lier les colonnes aux variables. C'est exactement le travail du \textit{ColumnSelectorView}. 

%--------------INSERER ICI UNE CAPTURE D'ECRAN DU COLONNESELECTORVIEW. DON'T FORGET--------------

D'un point de vue graphique cette interface n'est pas très interessante. La façon dont je l'ai implementé sera par contre très interessante pour le chapitre quatre, qui portera sur \textit{ce que j'ai appris durant ce stage}. La première monture de cette classe ne comportait pas la logique pour de la génération du schema. Ma conception de cette classe était un petit utilitaire qui ne sert qu'à choisir les champs, la génération du schema devait se faire autre part. Cette classe ne contenait qu'un modele de \textit{listener}\footnote{Un listener est une interface (au sens programatique du terme) qui réagit aux signaux d'un objet en particulier.} qui contenait une méthode que l'on appelait pour gênerer le schema. Ce listener était implémenté dans la classe qui gêrait le tableau. Pour moi, cela fait sens que la génération d'un graphique avec les données d'un tableau soit ordonnées par celui-ci. Ce n'est pas faux en soit, mis il y a mieux\ldots

%--------------INSERER ICI LE CODE DE L'INTERFACE YO--------------

%TODO : Quinze jours est faux, trouver le bon 
Quinze jours plus tard, le code de cette classe avait drastiquement changé. Je vais être honnête, je n'ai pas fais ces changements. John a commencé à me faire comprendre que ma façon de concevoir était très démodée en supprimant l'interface %Nom de l'interface
. Laissez moi vous expliquer plus en détails.

Nous utilisons dans le projet une librairie appelée \textit{ControlsFX}. Elle ajoute des éléments d'interface graphique qui ne sont pas dans la librairie originale, ainsi que la notion d'\textbf{Actions}. Une Action est une classe qui \textit{fait quelque chose en réaction à une demande de l'utilisateur}. Un de ses avantages est qu'elle est automatiquement transformée en élément d'interface par \textit{ControlsFX}. Exemple : une boite de dialogue a une série d'actions possibles en réaction à son affichage qu'elle tranforme en boutons.

John a tranformé ma classe qui était auparavant un simple élément affichable par \textit{JavaFX} en boite de dialogue de JavaFX. Elle était dorénavant mieux integrée stylistiquement à l'interface de l'application, et surtout, elle enlevait le \textit{listener} du tableau, et donnait à la logique de génération de tableau sa propre classe : une action. Bien plus propre.

Aujourd'hui cette Action est toujours une classe gigogne du \textit{ColumnSelectorView}, ce qui est selon toute l'équipe une place non idéale. Il faudra bientôt que l'on déplace toutes nos actions dans un package qui leur est dédié.

%
%
\subsection{Completion du convertisseur SVG}
Il ne restait alors plus qu'une seule tâche avant que l'implémentation du cas d'utilisation soit terminée : La conversion du graphique en un fichier SVG.

\begin{center}
Le SVG est un format graphique vectoriel. Un fichier au format SVG contient la définitions de diverse formes. Ces défintion comportent entre autres la positions de la position de la forme, la couleur de son tracé et de son remplissage, la largeur de son tracé \ldots.
\end{center}

\begin{center}
Un noeud (\textit{Node}) dans \textit{JavaFX} est la classe de base de n'importe quel élément affichable. La plupart du temps, on utilise des noeuds composés d'autre noeuds. Un simple bouton, par exemple, contient au moins un rectangle et un label\footnote{Nom d'un texte affiché à l'écran dans le jargon informatique}.
\end{center}

\begin{center}
Une scène (\textit{Scene}) est un ensemble de noeuds.
\end{center}

J'ai repris en charge l'écriture d'un convertisseur que John avait commencé à écrire. Ce convertisseur est conçu pour pouvoir transformer n'importe quel noeud en SVG. Pour cela il parcours tous les noeuds composés récursivement\footnote{La récursivité est un concept de l'informatique qui désigne la répétition d'une action entrainée par cette même action. Ici, l'action serait ``Parcourir les enfants''. Quand je \emph{parcours les enfants}, si je trouve un enfants qui en a d'autres, je \emph{parcours ses enfants}.}, et converti les noeuds de bases en éléments SVG. Nous nous en servons sur le noeud du graphique.

Avant que je travail dessus, voici comme le graphiques étaient rendus :
%----------------Image du rendu avant--------------

Le travail que j'ai du effectuer pour ce convertisseur est principalement un travail d'investigation. Il fallait que je trouve où et comment JavaFX définit les options grahiques des noeuds qu'il utilise au moment de rendre les noeuds.

Pour cela, j'ai tout d'abord regardé comment le noeud du graphique était composé. J'ai extrait la hierarchie des enfants du noeud du graphique :

\begin{verbatim}
ConcordiaChart@b721ec6[styleClass=chart]
   Label@58eeaa1f[styleClass=label chart-title]''
      Text[text="", x=0.0, y=0.0, alignment=LEFT, origin]
   Chart$1@5109fabb[styleClass=chart-content]
      Region@3078127b[styleClass=chart-plot-background]
      XYChart$1@206ec019
          Path[elements=[], fill=null, fillRule=NON_ZERO]
          Path[elements=[MoveTo[x=100.0, y=10.0], LineTo[x=1 
          Path[elements=[MoveTo[x=297.5, y=10.0], LineTo[x=2
          Path[elements=[MoveTo[x=100.0, y=646.5], LineTo[x 
          Line[startX=0.0, startY=0.0, endX=0.0, endY=0.0, s 
          Line[startX=0.0, startY=0.0, endX=0.0, endY=0.0, s
          Group@5867eb04[styleClass=plot-content]
              Group@789d6eba
                  Path[elements=[MoveTo[x=0.0, y=-57194.0], LineTo[x Invisible
              Group@400b7196[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=1023.0, y=62.0], CubicCurv
              Group@bddd852[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=798.0, y=206.0], CubicCurv
                  Circle[centerX=775.0, centerY=221.0, radius=3.0, f
              Group@27c9ed47[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=604.0, y=481.0], CubicCurv
                  Circle[centerX=583.0, centerY=497.0, radius=3.0, f
              Group@5c612db6[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=103.0, y=598.0], CubicCurv
                  Circle[centerX=83.0, centerY=615.0, radius=3.0, fi
              Group@1e4ce279[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=810.0, y=538.0], CubicCurv
                  Circle[centerX=789.0, centerY=557.0, radius=3.0, f
              Group@5eec36db[styleClass=error-ellipse]
                  Path[elements=[MoveTo[x=433.0, y=339.0], CubicCurv
                  Circle[centerX=411.0, centerY=352.0, radius=3.0, f
      NumberAxis@2b5f1854[styleClass=axis] Horizontal 
         Label@29a340ae[styleClass=label axis-label]'xxxPb/
              Text[text="xxxPb/xxxU", x=0.0, y=0.0, alignment=LE 207pb/235u
          Path[elements=[MoveTo[x=0.0, y=0.0], LineTo[x=0.0, 
          Path[elements=[MoveTo[x=40.0, y=1.0], LineTo[x=40. 
          Text[text="0.0720000", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0720500", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0721000", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0721500", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0722000", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0722500", x=0.0, y=0.0, alignment=LEF
      NumberAxis@2650091e[styleClass=axis]
          Label@2ea49c54[styleClass=label axis-label]'xxxPb/
              Text[text="xxxPb/xxxU", x=0.0, y=0.0, alignment=LE Invisible
          Path[elements=[MoveTo[x=82.0, y=636.0], LineTo[x=9
          Path[elements=[MoveTo[x=85.0, y=679.0], LineTo[x=8
          Text[text="0.0000800", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0001000", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0001200", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0001400", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0001600", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0001800", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0002000", x=0.0, y=0.0, alignment=LEF
          Text[text="0.0002200", x=0.0, y=0.0, alignment=LEF
      Rectangle[x=0.0, y=0.0, width=0.0, height=0.0, fil Empty
\end{verbatim}
J'ai cherché à savoir, en comparant avec les éléments du SVG déjà génèré par le code existant à quel élément graphique correspondait chacuns de ces éléments. Pour une meilleurs de ce qui suit, une capture d'écran d'un graphique a été placé après cette liste. On voit donc que le \textit{ConcordiaChart} est composé de :
\begin{itemize}
\item Un objet \textit{Label} : le titre du graphique
\item Un objet \textit{Chart} avec un objet \textit{XYChart} contenant :
  \begin{itemize}
  \item Des objets \textit{Path} : Les lignes étendant les graduations des axes
  \item Un objet \textit{Group} : Les objets affichés sur le graphique
    \begin{itemize}
    \item La ligne de temps est l'objet \textit{Path} dans le second \textit{Group}
    \item Les autres \textit{Group} contiennent un \textit{Path}, l'Ellipse, et un \textit{Circle}, le point au milieu de l'ellipse.
    \end{itemize}
  \end{itemize}
\item Deux objets \textit{Axis}, contenant chacun :
  \begin{itemize}
  \item Un \textit{Label} : la légende de l'axe
  \item Deux éléments \textit{Path} : Les grandes et petites marques de graduation
  \item Des éléments \textit{Text} : Les textes des graduations
  \end{itemize}
\end{itemize}
%Image du graphique sous JavaFX

J'ai ensuite été chercher dans le moteur de rendu de \textit{JavaFX} la logique qui rend une scene à l'écran. Mon plan (diabolique s'il en est), était de voir où cette logique récupère les options graphiques des objets qu'elle doit dessiner. Si mon plan a failli, me coutant quelques jours, j'ai néanmoins appris énormément sur la façon dont \textit{JavaFX} fonctionne. 

Pour résumer, le code de JavaFX est separé en deux :
\begin{enumerate}
\item La partie publique est celle que l'on utilise pour construire une scene, et plus génénalement pour intéragir avec la librairie. Elle contient aussi les \textit{Property}, dont je parlerais plus tard. Elle est sous le package %TODO noter le package avec Verbatim
\item La partie privée (joyeusement fouillie et peu commentée) a différents rôles:%TODO noter le package avec verbatim
  \begin{enumerate}	
  \item Rendre des scenes (Moteur de rendu \textit{Prism}, sur lequel je me suis particulierement penché)
  \item Unifier l'interaction avec les systèmes de fenêtrage des différents OS avec lesquels \textit{JavaFX} est compatible. (Module \textit{Glassfish})
  \item Rendre différents type de médias
  \item Rendu du HTML complet, (Moteur basé sur \textit{Webkit})
  \item Marcher sur plusieurs threads
  \end{enumerate}
\end{enumerate}

Après la faillite de mon premier plan, j'ai procédé plus simplement. Je suis revenu aux objets de l'API publique, ceux que nous manipulons quand nous créons une scène et ait cherché les différentes options graphique en leur seins. J'ai reussi à trouver et à orienter correctement le nom des axes et à repositionner ceux-ci, j'ai re-aligné les graduations, repositionné et affiché des lignes et des textes dans le graph.

%
%
%
\section{Réponse aux attente de la communauté GitHub}
Le module SVG était fini. Le cas d'utilisation était implémenté. Nous étions près à montrer le fruit de notre travail aux chercheurs Australiens, ce que nous avons fait le Jeudi% verifier que c'est  bien un jeudi 
21 mai par visioconférence. Ils étaient enchantés du prototype.

Le docteur Bowring a envoyé un lien vers le dépot GitHub du projet, et une petite mais active communauté s'est formée autour du projet. Ses membres nous envoient encore à ce jours des rapports de bug, des suggestions de fonctions.

Cela a bien sur beaucoup changer la dynamique de travail. Nos journées étaient à présent partagées entre réponses à la communauté, corrections rapides de bugs et developpement de fonctions plus complexes. Nous avons appris à penser à court et long termes.

Je vais à présent parler des deux dernières fonctions complexes que j'ai conçu et codé les semaines restantes.

%
%
\subsection{Ré-écriture de l'interface graphique avec \textit{FXML}}
Une fois le rush du prototype terminé, John s'est penché sur la documentation d'une fonction de \textit{JavaFX} qui avait attiré son attention un peu plus tôt. Il a lu ce qu'était \textit{FXML}, m'en a parlé et nous avons décidé qu'il serait de bon ton, pour le long terme, de ré-écrire les interfaces graphiques du programme avec. Nous nous sommes donc attelé à la tâche.

Le FXML est un langage basé sur la syntaxe XML\footnote{Le XML est une syntaxe standardisée permetant de représenter n'importe quelle données composées de caracteres normaux. De nombreux langages sont basés sur XML car la logique de décodage de la syntaxe est présente dans de nombreux langages. Quand ils écrivent un décodeurs pour leur données, les developpeurs ont juste besoin de se soucier de la grammaire et du vocabulaire, pas de la syntaxe.}. Il permet de représenter simplement les interfaces graphique d'un programme. Ainsi, il y a une meilleurs séparation du code : la structures des interfaces ont leur fichiers en \textit{FXML}, et leur comportement est codé en \textit{Java}.

Je vais vous expliquer ce que j'ai fais pour chaque fichier avec un exemple simple.
\begin{verbatim}
class SimplePane extends VBox{

  public SimplePane(){
    
    Label label = new Label("Vincent Vega");
    Button bouton = new Button("Change brother");
    bouton.setOnAction((ActionEvent e) -> {
      label.setText("Vic Vega");
    }

    getChildren().add(bouton);
    getChildren().add(label);
  }
}
\end{verbatim}

Nous avons ici une classe qui contient à la fois le comportement et à la fois la présentation de l'élément graphique qu'elle représente. Voyons le code de son constructeur :
\begin{verbatim}
Label label = new Label("Vincent Vega");
Button bouton = new Button("Change brother");
\end{verbatim}
Ici, on crée deux éléments graphiques, un label et un bouton, c'est du code de présentation

\begin{verbatim}
bouton.setOnAction((ActionEvent e) -> {
  label.setText("Vic Vega");
}
\end{verbatim}
Un comportement est ici assigné au bouton : ``Quand tu es cliqué, le texte du label deviendra : ``Vic Vega''''

\begin{verbatim}
getChildren().add(bouton);
getChildren().add(label);
\end{verbatim}
Ici, le label et le bouton sont ajoutés comme enfants de la classe.

Quand on transforme une classe dans l'optique qu'elle utilise \textit{FXML}, on enlève toutes ses partie de présentation et on les insere dans un fichier écrit avec FXML.
\begin{verbatim}
<? xml version="1.0" encoding="UTF-8" ?>

<!-- quelques imports ...->
<fx:root type="VBox">
    <Label fx:id="label" text="Vincent Vega"/>
    <Button text="Change Brother" onAction="#changeBrother"/>
</fx:root>
\end{verbatim}

On déplace ensuite son code de comportement dans des méthodes et on lui indique de construire les objets de présentation en suivant le fichier \textit{FXML} que l'on vient d'écrire :
\begin{verbatim}
class SimplePane extends VBox{

  @FXML Label label;

  public SimplePane(){
    FXMLLoader loader = new FXMLLoader(getClass().getResource("chartcustomizationpanel.fxml"),
                                           ResourceBundle.getBundle("org.cirdles.topsoil.Resources"));
    loader.setRoot(this);
    loader.setController(this);

    try {
      loader.load();
    } catch (IOException e) {
      getChildren().add(new Label("There was an error loading this part of the panel."));
      e.printStackTrace();
    }
  }

  @FXML
  private void changeBrother(){
    label.setText("Vic Vega");
  }
}
\end{verbatim}

Expliquons ce code en détail :
\begin{verbatim}
public SimplePane(){
  FXMLLoader loader = new FXMLLoader(getClass().getResource("chartcustomizationpanel.fxml"));
  loader.setRoot(this);
  loader.setController(this);
   try {
    loader.load();
  } catch (IOException e) {
    getChildren().add(new Label("There was an error loading this part of the panel."));
    e.printStackTrace();
  }
}
\end{verbatim}

Ceci est le constructeur de la classe. Il ne fait que construire les objets indiqués le fichier XML. Certains de ces objets sont ensuite placés dans ces variables ...
\begin{verbatim}
@FXML Label label;
\end{verbatim}
... car certaines des méthodes de comportement ont besoin d'y accèder. La méthode \textit{changerBrother} accède par exemple à la variable \textit{label}.

Il reste une dernière question. Comment l'interface graphique généré depuis le \textit{FXML} est liée au comportement ? Très simplement : dans le fichier \textit{FXML}, le bouton est lié par l'attribut \textit{onAction} à la méthode \textit{changerBrother}.

Cela peut sembler beaucoup de travail pour le même résultat en retour mais cette séparation entre la présentation et le comportement nous a fait gagné énormement de place et de clareté dans notre code.

Pendant que je refactorisais ces classes, je me suis aussi occupé de rendre le graphique personnalisable.

\subsection{Personnalisation du graphique}
Très tôt dans la seconde partie du projet, nous nous sommes aperçu de la necessité de personnaliser le graphique. Si \textit{Topsoil} est un outil de visualisation, c'est aussi un outil de génération de graphiques pour le partage et la publication. Dans cette optique, nous voulions donner la possibilité aux géochronologistes de créer un schema dans le même style que leur publications.

Les panneaux que j'ai conçu dans cette optique et que je vais vous présenter à présent dans leur version finale ont connues plusieurs formes. Les besoins auxquels répondait leur forme première m'avaient été donné par le Docteur Bowring. D'autres fonctionnalités, comme la personnalisation des limites du schema ou encore le renommage des axes nous ont ensuites été demandé par des utilisateurs via \textit{GitHub}.

%INSERER UNE IMAGE POUR DU PANNEAU

Il y a deux panneaux concentré en un. Celui pour configurer \emph{le style des éllipses} et le second qui permet de configurer \emph{le style du graphique}. Cette séparation est due au fait que dans le futur, il sera possible d'inserer plusieurs séries d'éllipses, et on pourra déterminer le style pour chacune d'entre elles. Il sera alors possible de multiplier aisement le premier panneau.

Ce premier panneau permet de modifier l'opacité et les couleurs du fond et des contours des ellipses. Cela permet de faire des choses aussi variées que ceci.

%INSERER DES IMAGES D'ELLIPSE DE DIFFERENTES COULEURS

Le deuxième panneau permet quand à lui de choisir le type de lignes Concordia que l'on souhaite afficher. Il permet ensuite pour chaque axes de configurer un certain nombres d'options pour les axes : 
\begin{itemize}
\item Le texte de sa légende
\item Ses limites
\item La distances qui sépare ses grandes graduations
\item La valeur à partir de laquelle le placement de ces grandes graduation sont calculés
\item Le nombre de petites graduation entre les grandes graduations
\end{itemize}

Le developpement de ces panneaux a été rendu facile par le système de \textit{Property} de JavaFX. Une \textit{Property} est la réponse de \textit{Oracle} dans \textit{JavaFX} à un problème qui faisait perdre beaucoup de temps au developpeurs. Avant quand on voulait que la valeure d'une variable soit modifiée quand une autre était changée, il fallait écrire une logique déclanchée à chaques modifications qui repercutait les changements sur la deuxième variable. Ce n'est déjà pas simple car il faut repèrer tous les endroits où un changement est effectué et lancer cette logique. Maintenant, imaginez le casse-tête que serait de lier les variables dans les deux sens. JavaFX simplifie ce problème en encapsulant la variable dans une \textit{Property}. On interagit plus directement avec la variable mais avec son conteneur. Il peut donc exectuer lui même la logique de modification. Mais il y a mieux. Dans le cas où l'on veut simplement que les valeurs de deux property soient repercutés l'ue sur l'autre, alors on peut simplement dire à \textit{JavaFX} de les lier. Tout bonnement merveilleux.

Les \textit{Property} sont utilisées partout dans JavaFX. N'importe quelle valeur, de la couleur d'une bordure à la largeur d'une fenêtre en est une. Tout ce que j'ai eu à faire est simplement lier les valeurs de mes formulaires aux propriétés auquelles elles étaient liées. 

Fait interessant à propos de ces graduations, 
