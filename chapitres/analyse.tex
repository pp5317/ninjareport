\chapter{Analyse du déroulement du stage}
Les retours de ce stage pour moi peuvent être classés en trois catégories : Technique, Culture Générale et Organisationnel.

\section{Technique}
Le retour le plus évident de ce stage au niveau technique est l'expérience acquise sur la librairie \textit{JavaFX}. Je ne la connaissais pas en arrivant à Charleston, et j'ai mis un peu de temps à assimiler les concepts qui n'étaient pas dans \textit{Swing}, sa principale source d'inspiration. Ces améliorations et trouvailles, comme les \textit{Property}, le système de hiérarchie des nœuds ou encore le FXML valent vraiment le coup d'être apprises et améliorent considérablement la vie du développeur. J'ai quelques reproches, rien de très grave, comme les bugs dus à la jeunesse de la librairie, la documentation parfois imprécise et pas des plus claires et la librairie de graphique assez limitée\footnote{Des modifications peu orthodoxes nous ont été nécessaire pour permettre à l'utilisateur de se déplacer dans le schéma}, mais dans l'ensemble c'est une excellente libraire que je réutiliserai et que j'explorerai plus en détails.

Nous utilisons \textit{JavaFX 8}, qui est compatible uniquement avec \textit{Java 8}, la dernière mouture du langage. J'ai pu découvrir les nouveautés de cette nouvelle version, et plus particulièrement les fonctions lambda. Une fonction lambda est une fonction anonyme, passée à une autre fonction. Imaginons une fonction qui trie des objets en fonction d'une règle particulière qui indique si l'objet est plus grand. Cette règle implémentée dans un objet comparateur est passée en paramètre de la fonction. Il faut donc créer cet objet comparateur à chaque fois que l'on appelle la fonction. La syntaxe pour faire ceci dans jusqu'a Java 7 était très lourde. On voyait plus que l'on créait un objet plutôt qu'une règle. Dans Java 8, on voit maintenant que l'on créé une règle. C'est très agréable !

Ce n'est ce cependant pas le concept le plus naturel dans le langage \textit{Java}. Java est basé sur le paradigme de Programmation Orientée Objet. Les fonctions lambda ont été créés pour le paradigme de Programmation Fonctionnelle. Il y a des langages basés uniquement sur le principe de Programmation Fonctionnelle que j'ai découvert pendant ce stage, comme \textit{Haskell}. Approfondir ses connaissances dans ce paradigme est assez compliqué puisqu'il faut changer sa façon de penser du tout au tout, je n'ai donc pas eut vraiment le temps de me pencher dessus. Mais ce manque de temps n'est que temporaire.

J'ai joué avec le \textit{SVG}, je comprends un peu mieux comment marche ce format. J'ai aussi appris à utiliser Maven, un logiciel qui automatise la compilation de notre code. Souvent quand des entreprises compilent des logiciels, elles produisent plusieurs versions : debuggage, production, production pour un certain client... Avant cela, elles testent le code qu'elle compile. Maven permet d'automatiser ces tests compilations. Il gêre aussi l'intégration des librairies que l'on utilise directement. Ce n'est désormais plus au développeur de réunir toutes les librairies dépendantes avant de compiler. Très pratique. 

Un outil qui m'a apporté des retours à la fois du côté technique et du côté organisationel : \textit{Git}, un outil de collaboration  basé sur quelques principes simples. Cela n'empêche pas ses possibilités d'être tellement étendues que cela le rend fascinant.J'avais déja quelques experiences avec \textit{Git} mais l'utiliser au quotidien m'a permis de vraiment me rendre compte de sa puissance. Un peu plus en particulier, j'ai appris à utiliser efficacement les branches, la difference entre pull et fetch, et différentes manières de communiquer et collaborer entre les dépôts.

\textit{GitHub} est un réseau social apportant ses fonctionnalités à internet et offrant d'autres services autour de Git. J'ai appris à communiquer et à collaborer sur ce site web. Je sais maintenant retrouver les différentes fonctionnalité de Git directement en ligne, je sais aussi utiliser leur \textit{Issues Tracker} et sais comment faire une pull request. Je fais maintenant énormement de choses avec \textit{Git} et \textit{Github}. Ce rapport de stage est par exemple entièrement gêré avec \textit{Git} et disponible sur mon compte \textit{GitHub}.
Voyons comment Git a modelé notre façon de travailler en équipe.

%%Mentionner GitHub Pages (parce que sérieux, quoi de mieux ?)

\section{L'organisation}

\subsection{L'organisation de l'équipe}
L'intégralité de notre travail est organisé avec \textit{Gitub}. Notre code source y est dans un "dépôt", et c'est grâce à cela que nous fusionnons nos différents travaux. Nos listes de tâches évolue dynaniquement sur l'\textit{issue tracker}. Une \textit{issue} est crée par fonctionnalité à implémenter ou bug à résoudre pour nous ou nos utilisateurs. On en discute entre nous ou avec les utilisateurs. Nous nous les assignons ensuite, et nous les assignons aussi à une version, version qui a une date de sortie. Une issue est ouverte quand elle requiert du travail. Elles sont fermées automatiquement quand un "commit" la résoud. C'est sur ce tracker que nous voyons l'avancée du travail, que nous prévoyons le futur du développement et que l'on communique avec nos utilisateurs.

J'ai aussi expérimenté vers la fin de ce stage le développement à plusieurs vitesse. Le projet va bientôt commencer le développement d'une grande librairie ce qui va sans aucun doute prendre plusieurs mois. Pendant ce temps, la réponse aux besoins urgents des utilisateurs, tels que correction de bugs et autres fonctionalités rapides à coder ne va pas s'arrêter. Nous cherchons donc un moyen d'organiser l'équipe pour qu'elle reste efficace sur et entre ces deux fronts. Il y a plusieurs façons de faire ceci et elles influent sur deux facteurs : la répartition du travail dans la journée, dans la semaine et entre les hommes. La solution que nous expérimentons en ce moment est une semaine de développement court et une semaine de recherche pour la librairie. Cela pose cependant des problèmes, notamment le fait de laisser des utilisateurs sans réponse.

Sur ce point j'ai fais une autre découverte que j'ai appris à gêrer (notemment grâce à un fantastique article trouvé sur Reddit)%AJOUTER UNE REFERENCE À L'ARTICLE
: Un projet ne se fait pas à vitesse constante. Il y a des périodes, périodes de rush, où on est plongé dans le développement d'une fonctions. C'est très agréable à court terme, on apprend beaucoup et on produit beaucoup. Mais on ne peut pas, et on ne doit surtout pas rester dans ce mode trop longtemps, d'une parce que le code produit n'est pas très glorieux, et de deux parce que l'équipe risque de s'essouffler et de produire de moins en moins, et surtout de moins en moins bien. Un autre mode est ce que l'on appelle le mode marathon. L'équipe produit, mais passe aussi du temps à côté à se relaxer, à apprendre, ou à réfléchir. Et puis il y a les bien aimés jours lents, ou il ne se passe que peu de choses, et la majorité du temps est passé sur Youtube ou South Park Studio. Ah... le vendredi !

Documenter et écrire des tests sur un projet n'est pas notre fort. J'ai appris pendant ce projet que malgré toute la bonne volonté que l'on peut mettre dans ces tâches au départ, on se retrouve bien souvent le nez dans le développement de fonctions compliqués et on oublie ces apports considérables au long terme. Il s'agit vraiment de prendre l'habitude de les écrires et d'accepter que si le développement d'une fonction est forcement ralongé, c'est pour le bien des programmes, des utilisateurs et de l'équipe. J'ai encore beaucoup de progrès à faire dans ce domaine.

\subsection{Ma façon de concevoir un programme}

\begin{center}Le principe KISS : Keep it simple, stupid !\end{center}

Si je ne retenais qu'une seule chose de stage\footnote{Ce qui serait diablement stupide}, ce serait que ma façon de concevoir un programme à énormement changée. Je suis arrivé aux États-Unis en produisant au départ des fonctions comme je l'ai toujours fait. : elles répondent à un maximum de cas d'utilisation et sont très complexes. Le petit problème que j'ai appris à éviter c'est qu'elles répondent à des problèmes que l'équipe et le programme n'ont pas encore, et n'auront peut-être jamais. Et surtout, elles rajoutent trop de complexité au code. J'ai du bien souvent simplifier ma façon de penser pour que le code ne devienne pas une jungle.

J'ai donc cessé de produire des codes à interfaces qui produisait trop pour le futur, et j'ai commencé à me demander \emph{pourquoi je concevais mon code comme ça}, \emph{à qui cela allait profiter}, et : \emph{textbf{``N'y a t-il pas un moyen de le faire plus simplement ??''}}.

\begin{quote}
``Perfect is the ennemy of good'' - Jim Bowring
\end{quote}

Voilà un autre principe que j'ai au premier abord détesté puis que j'ai appris à aimé tout au long de ces 13 semaines. Produire du code parfait est dur, très dur. Cela demande beaucoup de compétences, de la concentration et de la planification. Et surtout, cela énormément de temps. La recherche de la perfection fait dépasser les "deadlines", pousse à faire et à refaire et à refaire. Les développeurs se fatiguent et les clients ne sont pas contents du retard. Foncer et ne pas se pencher sur les détails à ceci de très, très positif : on finit et on publie la fonction. C'est un soulagement pour les développeurs, les clients sont contents. Par contre, cela apporte de la dette technique\footnote{Terme recemment inventé qui désigne le degré de mauvais code dans le projet}. Comme toute dette, il faut l'emprunter intelligement, en pensant à la façon dont on va la rembourser, pour éviter d'avoir un code trop gangrainé.

\section{Culture Générale}
\subsection{Geochronologie}
J'ai un peu appris ce qu'était la géochronologie. Je sais maintenant qu'il n'y a pas que le carbon 14 qui permet de dater des objets terrestres, et que le travail des géochronologistes est important pour garder notre espèce en vie. Ils étudient en effet différentes catastrophe naturelle ayant causé la mort d'espèces entières, comme les dinosaures. Ils cherchent la durée de ces catastrophes, leur causes et comment nous pouvons nous en proteger. Il a récemment été prouvé qu'une éruption volcanique de seulement une dizaine de miliers d'années avait presque éradiqué la vie sur notre planète.
Je sais aussi maintenant que l'uranium se transforme en plomb avec le temps, ce qu'est une capsule et ce qu'est le zircon.

Dans le champ des sciences, j'ai aussi amélioré mes connaissances en statistiques et mis à profit mes connaissances en statistiques. Je comprends mieux maintenant ce que sont les marges d'erreurs et comment les utiliser.

\subsection{Marché du travail français et américain}
Après avoir longuement discuté du sujet avec différentes personnes, je me rends comptes des différences entre ce que les entreprises américaines et françaises requièrent à l'embauche et entre leurs méthodes de travail. 

En France, le diplôme est très important, celui d'ingénieur ouvre les portes de grandes entreprises et de postes intéressants. Aux États-Unis, si obtenir son "bachelor" est important, c'est ce que l'on fait à côté qui montre la différence. Les étudiants sont encouragés à publier, contribuer à des projets open source, à faire des stages d'\emph{informatique} l'été ou encore à intégrer des laboratoires de recherches. Le cursus seul ne donne rien de bien intéressant.

En France, j'ai aussi l'impression que le système est très hiérarchique. Les employés ont un patron, des ordres, progressent en hiérarchie avant de pouvoir prendre des décisions. Aux États-Unis au contraire, l'innovation est encouragée. Un jeune employé peut aller voir son "boss" et lui proposer un projet. Si celui-ci est bénéfique pour l'entreprise alors il aura la responsabilité de le mettre en place. 

Deux façons de penser très différentes.

\subsection{Graphiques}
J'ai du vers la fin de mon stage résumé un livre en entier sur les graphiques. C'était une expérience intéressante et j'ai appris énormément sur les qualités qui font une bonne visualisation de données en générales, les différentes possibilités offertes par les différents types de graphique, à quel point un graphique peu aussi être trompeur sur les données qu'il pense représenter, et à quel point cela peut être un excellent moyen de communication. Je sais aussi maintenant grâce à cette expérience ingurgiter beaucoup d'informations en très peu de temps, un atout très profitable.
